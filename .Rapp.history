head(prices)
head(prices,10)
library('lubridate')#
#
prices <- transform(prices, Date = ymd(Date))
head(prices)
library('reshape')#
#
date.stock.matrix <- cast(prices, Date ~ Stock, value = 'Close')
head(date.stock.matrix)
prices <- subset(prices, Date != ymd('2002-02-01'))
head(prices)
head(prices,15)
prices <- subset(prices, Stock != 'DDR')
date.stock.matrix <- cast(prices, Date ~ Stock, value = 'Close')
head(date.stock.matrix)
cor.matrix <- cor(date.stock.matrix[, 2:ncol(date.stock.matrix)])#
correlations <- as.numeric(cor.matrix)
cor.matrix
ggplot(data.frame(Correlation = correlations),#
  aes(x = Correlation, fill = 1)) +#
  geom_density() +#
  theme(legend.position = 'none')
head(correlations)
length(correlations)
pca <- princomp(data.stock.matrix[, 2:ncol(date.stock.matrix)])
pca <- princomp(date.stock.matrix[, 2:ncol(date.stock.matrix)])
head(date.stock.matrix)
head(date.stock.matrix[, 2:ncol(date.stock.matrix)])
pca
head(pca$loadings)
head(pca$loadings[,1])
head(pca$loadings[,3])
head(pca$loadings[,1:3])
head(pca$loadings[,1:4])
principal.component <- pca$loadings[, 1]
loadings <- as.numeric(principal.component)
head(loadings)
ggplot(data.frame(Loading = loadings),#
  aes(x = Loading, fill = 1)) +#
  geom_density() +#
  theme(legend.position = 'none')
head(predict(pca))
market.index <- predict(pca)[, 1]
dji.prices <- read.csv(file.path('data', 'DJI.csv'),#
                       stringsAsFactors = FALSE)#
dji.prices <- transform(dji.prices, Date = ymd(Date))
dji.prices <- read.csv(file.path('08-PCA','data', 'DJI.csv'),#
                       stringsAsFactors = FALSE)
dji.prices <- transform(dji.prices, Date = ymd(Date))
dji.prices <- subset(dji.prices, Date > ymd('2001-12-31'))#
dji.prices <- subset(dji.prices, Date != ymd('2002-02-01'))
dji <- with(dji.prices, rev(Close))#
dates <- with(dji.prices, rev(Date))
head(dji.prices)
head(rev(Close))
with(dji.prices, rev(Close))
head(with(dji.prices, rev(Close)))
comparison <- data.frame(Date = dates,#
                         MarketIndex = market.index,#
                         DJI = dji)
head(comparison)
head(market.index)
ggplot(comparison, aes(x = MarketIndex, y = DJI)) +#
  geom_point() +#
  geom_smooth(method = 'lm', se = FALSE)
?melt
alt.comparison <- melt(comparison, id.vars = 'Date')#
#
names(alt.comparison) <- c('Date', 'Index', 'Price')
head(alt.comparison)
ggplot(alt.comparison,#
       aes(x = Date, y = Price, group = Index, color = Index)) +#
  geom_point() +#
  geom_line()
?melt
head(alt.comparison,15)
tail(alt.comparison,15)
comparison <- transform(comparison, MarketIndex = scale(MarketIndex))#
comparison <- transform(comparison, DJI = scale(DJI))
head(comparison)
?scale
alt.comparison <- melt(comparison, id.vars = 'Date')
head(alt.comparison)
names(alt.comparison) <- c('Date', 'Index', 'Price')
ggplot(alt.comparison, aes(x = Date, y = Price, group = Index, color = Index)) +#
  geom_point() +#
  geom_line()
plot <- ggplot(alt.comparison, aes(x = Date, y = Price, group = Index, color = Index)) +#
  geom_point() +#
  geom_line()
ggsave(plot = plot,#
       filename = file.path("08-PCA","result.pdf"),#
       height = 4.8,#
       width = 7)
data.frame(u = c(5,10,15,20,30,40,60,80,100),#
                lot1 = c(118,58,42,35,27,25,21,19,18),#
                lot2 = c(69,35,26,21,18,16,13,12,12))
df <-data.frame(u = c(5,10,15,20,30,40,60,80,100),#
                lot1 = c(118,58,42,35,27,25,21,19,18),#
                lot2 = c(69,35,26,21,18,16,13,12,12)
)
df
glm(lot1 ~ log(u))
?dplyr
?ddplyr
?lm
?lm
ages <- read.csv(file.path('05-Regression','data', 'longevity.csv'))
head(ages)
head(ages,15)
tail(ages,15)
ggplot(ages, aes(x = AgeAtDeath, fill = factor(Smokes))) +#
  geom_density() +#
  facet_grid(Smokes ~ .)
guess <- 73
with(ages, mean((AgeAtDeath - guess) ^ 2))
guess.accuracy <- data.frame()
for (guess in seq(63, 83, by = 1))
{#
  prediction.error <- with(ages,#
                           mean((AgeAtDeath - guess) ^ 2))
guess.accuracy <- rbind(guess.accuracy,#
                          data.frame(Guess = guess,#
                                     Error = prediction.error))}
head(guess.acrruracy)
head(guess.accuracy)
ggplot(guess.accuracy, aes(x = Guess, y = Error)) +#
  geom_point() +#
  geom_line()
top.1000.sites <- read.csv(file.path('04-Regression','data', 'top_1000_sites.tsv'),#
                           sep = '\t',#
                           stringsAsFactors = FALSE)
top.1000.sites <- read.csv(file.path('05-Regression','data', 'top_1000_sites.tsv'),#
                           sep = '\t',#
                           stringsAsFactors = FALSE)
ggplot(top.1000.sites, aes(x = PageViews, y = UniqueVisitors)) +#
  geom_point()
ggplot(top.1000.sites, aes(x = PageViews)) +#
  geom_density()
ggplot(top.1000.sites, aes(x = log(PageViews))) +#
  geom_density()
ggplot(top.1000.sites, aes(x = log(PageViews), y = log(UniqueVisitors))) +#
  geom_point()
ggplot(top.1000.sites, aes(x = log(PageViews), y = log(UniqueVisitors))) +#
  geom_point() +#
  geom_smooth(method = 'lm', se = FALSE)
lm.fit <- lm(log(PageViews) ~ log(UniqueVisitors),#
             data = top.1000.sites)
summary(lm.fit)
x <- 1:10#
y <- x ^ 2
ggplot(data.frame(X = x, Y = y), aes(x = X, y = Y)) +#
  geom_point() +#
  geom_smooth(method = 'lm', se = FALSE)
cor(x, y)
scale(y)
scale(x)
coef(lm(scale(y) ~ scale(x)))
lm(scale(y) ~ scale(x)
)
set.seed(1)#
#
x <- seq(-10, 10, by = 0.01)#
y <- 1 - x ^ 2 + rnorm(length(x), 0, 5)
ggplot(data.frame(X = x, Y = y), aes(x = X, y = Y)) + #
  geom_point() +#
  geom_smooth(se = FALSE)
set.seed(1)#
#
x <- seq(0, 1, by = 0.01)#
y <- sin(2 * pi * x) + rnorm(length(x), 0, 0.1)
df <- data.frame(X = x, Y = y)#
#
ggplot(df, aes(x = X, y = Y)) +#
  geom_point()
summary(lm(Y ~ X, data = df))
df <- transform(df, X2 = X ^ 2)
df <- transform(df, X3 = X ^ 3)#
#
summary(lm(Y ~ X + X2 + X3, data = df))
head(df)
a <- 1:10
poly(a, degree=2, raw=TRUE)
poly(a, degree=3, raw=TRUE)
poly(a, degree=3, raw=FALSE)
a
a <-1:3
set.seed(1)
x <- seq(0, 1, by = 0.01)#
y <- sin(2 * pi * x) + rnorm(length(x), 0, 0.1)
(x,y)
ggplot(data.frame(X=x,Y=y), aes(x=X,y=Y))+geom_dots()
ggplot(data.frame(X=x,Y=y), aes(x=X,y=Y))+geom_points()
ggplot(data.frame(X=x,Y=y), aes(x=X,y=Y))+geom_point()
x <- as.matrix(cbind(x,rev(x)))
x
x <- seq(0, 1, by = 0.01)
glmnet(x, y)
x <- as.matrix(cbind(x,rev(x)))
glmnet(x, y)
?glmnet
x
names(x,"x","x1")
?names
names(x) <-"x","x1"
names(x) <-c("x","x1")
x
x <- seq(0, 1, by = 0.01)
x <- as.matrix(cbind(x,0))
x
glmnet(x, y)
x <- seq(0, 1, by = 0.01)
x <- as.matrix(cbind(x,1))
x
glmnet(x, y)
?glmnet
x <- seq(0, 1, by = 0.01)
glmnet(x, y)
set.seed(1)#
#
x <- seq(0, 1, by = 0.01)#
y <- sin(2 * pi * x) + rnorm(length(x), 0, 0.1)#
#
n <- length(x)
sort(sample(1:n, round(0.5 * n)))
indices <- sort(sample(1:n, round(0.5 * n)))
training.x <- x[indices]#
training.y <- y[indices]
test.x <- x[-indices]#
test.y <- y[-indices]
df <- data.frame(X = x, Y = y)
head(df)
training.df <- data.frame(X = training.x, Y = training.y)#
test.df <- data.frame(X = test.x, Y = test.y)
head(trainin.df)
head(training.df)
rmse <- function(y, h)#
{#
  return(sqrt(mean((y - h) ^ 2)))#
}
with(training.df, glmnet(poly(X, degree = 10), Y))
lambdas <- glmnet.fit$lambda
performance <- data.frame()
for (lambda in lambdas)
{#
  performance <- rbind(performance,
data.frame(Lambda = lambda,#
                                  RMSE = rmse(test.y,
with(test.df,#
                                                   predict(glmnet.fit,#
                                                           poly(X, degree = 10),#
                                                           s = lambda)))))#
}
for (lambda in lambdas)#
{#
  performance <- rbind(performance,data.frame(Lambda = lambda, RMSE = rmse(test.y,#
       with(test.df, predict(glmnet.fit, poly(X, degree = 10), s = lambda)))))#
}
?predict
head(performance)
predict(glmnet.fit, poly(x, degree = 10), s=0.543)
predict(glmnet.fit, poly(x, degree = 10), s=lambdas)
predict(glmnet.fit, poly(x, degree = 10))
predict(glmnet.fit, poly(x, degree = 10), s=0.543)
with(test.df(predict(glmnet.fit, poly(x, degree = 10), s=0.543)))
training.df <- data.frame(X = training.x, Y = training.y)#
test.df <- data.frame(X = test.x, Y = test.y)
with(test.df(predict(glmnet.fit, poly(x, degree = 10), s=0.543)))
with(test.df, predict(glmnet.fit, poly(x, degree = 10), s=0.543))
predict(glmnet.fit, poly(x, degree = 10), s=0.543)
test.y
ggplot(performance, aes(x = Lambda, y = RMSE)) +#
  geom_point() +#
  geom_line()
performance
best.lambda <- with(performance, Lambda[which(RMSE == min(RMSE))])
glmnet.fit <- with(df, glmnet(poly(X, degree = 10), Y))
glmnet.fit
head(df)
coef(glmnet.fit, s = best.lambda)
head(glm.fit)
?head
?coef
coef(glmnet.fit)
?DocumentTermMatrix
ranks <- read.csv(file.path('06-Regularization','data', 'oreilly.csv'),#
                  stringsAsFactors = FALSE)
library('tm')#
#
documents <- data.frame(Text = ranks$Long.Desc.)#
row.names(documents) <- 1:nrow(documents)
head(documents)
documents <- data.frame(doc_id = ranks$IP_Family,text = ranks$Long.Desc.)
head(documents)
corpus <- Corpus(DataframeSource(documents))#
corpus <- tm_map(corpus, tolower)#
corpus <- tm_map(corpus, stripWhitespace)#
corpus <- tm_map(corpus, removeWords, stopwords('english'))
corpus
head(corpus)
head(corpus)
corpus
dtm <- DocumentTermMatrix(corpus)
head(dtm)
dtm
x <- as.matrix(dtm)#
y <- rev(1:100)
set.seed(1)#
#
library('glmnet')
performance <- data.frame()
for (lambda in c(0.1, 0.25, 0.5, 1, 2, 5))#
{#
  for (i in 1:20)#
  {#
    indices <- sample(1:100, 80)#
    training.x <- x[indices, ]#
    training.y <- y[indices]#
    test.x <- x[-indices, ]#
    test.y <- y[-indices]#
    glm.fit <- glmnet(training.x, training.y)#
    predicted.y <- predict(glm.fit, test.x, s = lambda)#
    rmse <- sqrt(mean((predicted.y - test.y) ^ 2))#
#
    performance <- rbind(performance,#
                         data.frame(Lambda = lambda,#
                                    Iteration = i,#
                                    RMSE = rmse))#
  }#
}
ggplot(performance, aes(x = Lambda, y = RMSE)) +#
  stat_summary(fun.data = 'mean_cl_boot', geom = 'errorbar') +#
  stat_summary(fun.data = 'mean_cl_boot', geom = 'point')
indices <- sample(1:100,80)
train.x <- x[indices, ]
train.y <- y [indices]
head(train.x)
head(train.y)
test.x <- x[-indices, ]
test.y <- y[-indices]
head(test.y)
glmnet(train.x, train.y)
predicted.y <- predict(glm.fit, test.x, s = 0.1)
predicted.y
?predict
?predict
head(performanc)
head(performance)
head(performance,10)
rmse <- sqrt(mean((predicted.y - test.y) ^ 2))
rmse
test.y
mean((predicted.y - test.y) ^ 2)
(predicted.y - test.y) ^ 2
predicted.y <- predict(glm.fit, test.x, s = 0.1)
predicted.y
y <- rep(c(1, 0), each = 50)
regularized.fit <- glmnet(x, y, family = 'binomial')
regularized.fit
x
y
regularized.fit
predict(regularized.fit, newx = x, s=0.001)
?newx
??newx
head(x)
predict(regularized.fit, newx = x, s=0.001)
predict(regularized.fit, x, s=0.001)
ifelse(predict(regularized.fit, newx = x, s = 0.001) > 0, 1, 0)
library('boot')#
#
inv.logit(predict(regularized.fit, newx = x, s = 0.001))
set.seed(1)#
#
performance <- data.frame()
for (i in 1:250)#
{#
  indices <- sample(1:100, 80)#
  training.x <- x[indices, ]#
  training.y <- y[indices]#
  test.x <- x[-indices, ]#
  test.y <- y[-indices]#
  for (lambda in c(0.0001, 0.001, 0.0025, 0.005, 0.01, 0.025, 0.5, 0.1))#
  {#
    glm.fit <- glmnet(training.x, training.y, family = 'binomial')#
    predicted.y <- ifelse(predict(glm.fit, test.x, s = lambda) > 0, 1, 0)#
    error.rate <- mean(predicted.y != test.y)#
#
    performance <- rbind(performance,#
                         data.frame(Lambda = lambda,#
                                    Iteration = i,#
                                    ErrorRate = error.rate))#
  }#
}
head(performance,10)
head(performance,20)
head(performance,25)
ggplot(performance, aes(x = Lambda, y = ErrorRate)) +#
  stat_summary(fun.data = 'mean_cl_boot', geom = 'errorbar') +#
  stat_summary(fun.data = 'mean_cl_boot', geom = 'point') +#
  scale_x_log10()
